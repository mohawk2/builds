.\" Automatically generated by Pod::Man version 1.15
.\" Fri Dec 19 21:06:07 2014
.\"
.\" Standard preamble:
.\" ======================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R

.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used
.\" to do unbreakable dashes and therefore won't be available.  \*(C` and
.\" \*(C' expand to `' in nroff, nothing in troff, for use with C<>
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr
.\" for titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and
.\" index entries marked with X<> in POD.  Of course, you'll have to process
.\" the output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it
.\" makes way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.bd B 3
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ======================================================================
.\"
.IX Title "TAP::Parser::Scheduler 3"
.TH TAP::Parser::Scheduler 3 "perl v5.6.2" "2014-11-05" "User Contributed Perl Documentation"
.UC
.SH "NAME"
\&\s-1TAP:\s0:Parser::Scheduler \- Schedule tests during parallel testing
.SH "VERSION"
.IX Header "VERSION"
Version 3.34
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use TAP::Parser::Scheduler;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.SH "METHODS"
.IX Header "METHODS"
.Sh "Class Methods"
.IX Subsection "Class Methods"
.if n .I "\f(CW""new""\fP"
.el .I "\f(CWnew\fP"
.IX Subsection "new"
.PP
.Vb 5
\&    my $sched = TAP::Parser::Scheduler->new(tests => \e@tests);
\&    my $sched = TAP::Parser::Scheduler->new(
\&        tests => [ ['t/test_name.t','Test Description'], ... ],
\&        rules => \e%rules,
\&    );
.Ve
Given 'tests' and optional 'rules' as input, returns a new
\&\f(CW\*(C`TAP::Parser::Scheduler\*(C'\fR object.  Each member of \f(CW\*(C`@tests\*(C'\fR should be either a
a test file name, or a two element arrayref, where the first element is a test
file name, and the second element is a test description. By default, we'll use
the test name as the description.
.PP
The optional \f(CW\*(C`rules\*(C'\fR attribute provides direction on which tests should be run
in parallel and which should be run sequentially. If no rule data structure is
provided, a default data structure is used which makes every test eligible to
be run in parallel:
.PP
.Vb 1
\&    { par => '**' },
.Ve
The rules data structure is documented more in the next section.
.Sh "Rules data structure"
.IX Subsection "Rules data structure"
The "\f(CW\*(C`rules\*(C'\fR\*(L" data structure is the the heart of the scheduler. It allows you
to express simple rules like \*(R"run all tests in sequence\*(L" or \*(R"run all tests in
parallel except these five tests.". However, the rules structure also supports
glob-style pattern matching and recursive definitions, so you can also express
arbitarily complicated patterns.
.PP
The rule must only have one top level key: either 'par' for \*(L"parallel\*(R" or 'seq'
for \*(L"sequence\*(R".
.PP
Values must be either strings with possible glob-style matching, or arrayrefs
of strings or hashrefs which follow this pattern recursively.
.PP
Every element in an arrayref directly below a 'par' key is eligible to be run
in parallel, while vavalues directly below a 'seq' key must be run in sequence.
.PP
.I "Rules examples"
.IX Subsection "Rules examples"
.PP
Here are some examples:
.PP
.Vb 2
\&    # All tests be run in parallel (the default rule)
\&    { par => '**' },
.Ve
.Vb 2
\&    # Run all tests in sequence, except those starting with "p"
\&    { par => 't/p*.t' },
.Ve
.Vb 7
\&    # Run all tests in parallel, except those starting with "p"
\&    {
\&        seq => [
\&                  { seq => 't/p*.t' },
\&                  { par => '**'     },
\&               ],
\&    }
.Ve
.Vb 9
\&    # Run some  startup tests in sequence, then some parallel tests than some
\&    # teardown tests in sequence.
\&    {
\&        seq => [
\&            { seq => 't/startup/*.t' },
\&            { par => ['t/a/*.t','t/b/*.t','t/c/*.t'], }
\&            { seq => 't/shutdown/*.t' },
\&        ],
\&    },
.Ve
.I "Rules resolution"
.IX Subsection "Rules resolution"
.Ip "\(bu By default, all tests are eligible to be run in parallel. Specifying any of your own rules removes this one." 4
.IX Item "By default, all tests are eligible to be run in parallel. Specifying any of your own rules removes this one."
.PD 0
.if n .Ip "\(bu """"First match wins"""". The first rule that matches a test will be the one that applies." 4
.el .Ip "\(bu ``First match wins''. The first rule that matches a test will be the one that applies." 4
.IX Item ""First match wins. The first rule that matches a test will be the one that applies."
.Ip "\(bu Any test which does not match a rule will be run in sequence at the end of the run." 4
.IX Item "Any test which does not match a rule will be run in sequence at the end of the run."
.Ip "\(bu The existence of a rule does not imply selecting a test. You must still specify the tests to run." 4
.IX Item "The existence of a rule does not imply selecting a test. You must still specify the tests to run."
.if n .Ip "\(bu Specifying a rule to allow tests to run in parallel does not make the run in parallel. You still need specify the number of parallel \f(CW""""jobs""""\fR in your Harness object." 4
.el .Ip "\(bu Specifying a rule to allow tests to run in parallel does not make the run in parallel. You still need specify the number of parallel \f(CWjobs\fR in your Harness object." 4
.IX Item "Specifying a rule to allow tests to run in parallel does not make the run in parallel. You still need specify the number of parallel jobs in your Harness object."
.PD
.PP
.I "Glob-style pattern matching for rules"
.IX Subsection "Glob-style pattern matching for rules"
.PP
We implement our own glob-style pattern matching. Here are the patterns it supports:
.PP
.Vb 5
\&    ** is any number of characters, including /, within a pathname
\&    * is zero or more characters within a filename/directory name
\&    ? is exactly one character within a filename/directory name
\&    {foo,bar,baz} is any of foo, bar or baz.
\&    \e is an escape character
.Ve
.Sh "Instance Methods"
.IX Subsection "Instance Methods"
.if n .I "\f(CW""get_all""\fP"
.el .I "\f(CWget_all\fP"
.IX Subsection "get_all"
.PP
Get a list of all remaining tests.
.PP
.if n .I "\f(CW""get_job""\fP"
.el .I "\f(CWget_job\fP"
.IX Subsection "get_job"
.PP
Return the next available job as the TAP::Parser::Scheduler::Job manpage object or
\&\f(CW\*(C`undef\*(C'\fR if none are available. Returns a the TAP::Parser::Scheduler::Spinner manpage if
the scheduler still has pending jobs but none are available to run right now.
.PP
.if n .I "\f(CW""as_string""\fP"
.el .I "\f(CWas_string\fP"
.IX Subsection "as_string"
.PP
Return a human readable representation of the scheduling tree.
For example:
.PP
.Vb 3
\&    my @tests = (qw{
\&        t/startup/foo.t 
\&        t/shutdown/foo.t
.Ve
.Vb 12
\&        t/a/foo.t t/b/foo.t t/c/foo.t t/d/foo.t
\&    });
\&    my $sched = TAP::Parser::Scheduler->new(
\&        tests => \e@tests,
\&        rules => {
\&            seq => [
\&                { seq => 't/startup/*.t' },
\&                { par => ['t/a/*.t','t/b/*.t','t/c/*.t'] },
\&                { seq => 't/shutdown/*.t' },
\&            ],
\&        },
\&    );
.Ve
Produces:
.PP
.Vb 18
\&    par:
\&      seq:
\&        par:
\&          seq:
\&            par:
\&              seq:
\&                't/startup/foo.t'
\&            par:
\&              seq:
\&                't/a/foo.t'
\&              seq:
\&                't/b/foo.t'
\&              seq:
\&                't/c/foo.t'
\&            par:
\&              seq:
\&                't/shutdown/foo.t'
\&        't/d/foo.t'
.Ve
