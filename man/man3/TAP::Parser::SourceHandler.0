.\" Automatically generated by Pod::Man version 1.15
.\" Fri Dec 19 21:06:07 2014
.\"
.\" Standard preamble:
.\" ======================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R

.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used
.\" to do unbreakable dashes and therefore won't be available.  \*(C` and
.\" \*(C' expand to `' in nroff, nothing in troff, for use with C<>
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr
.\" for titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and
.\" index entries marked with X<> in POD.  Of course, you'll have to process
.\" the output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it
.\" makes way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.bd B 3
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ======================================================================
.\"
.IX Title "TAP::Parser::SourceHandler 3"
.TH TAP::Parser::SourceHandler 3 "perl v5.6.2" "2014-11-05" "User Contributed Perl Documentation"
.UC
.SH "NAME"
\&\s-1TAP:\s0:Parser::SourceHandler \- Base class for different \s-1TAP\s0 source handlers
.SH "VERSION"
.IX Header "VERSION"
Version 3.34
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  # abstract class - don't use directly!
\&  # see TAP::Parser::IteratorFactory for general usage
.Ve
.Vb 5
\&  # must be sub-classed for use
\&  package MySourceHandler;
\&  use base 'TAP::Parser::SourceHandler';
\&  sub can_handle    { return $confidence_level }
\&  sub make_iterator { return $iterator }
.Ve
.Vb 1
\&  # see example below for more details
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is an abstract base class for the TAP::Parser::Source manpage handlers / handlers.
.PP
A \f(CW\*(C`TAP::Parser::SourceHandler\*(C'\fR does whatever is necessary to produce & capture
a stream of \s-1TAP\s0 from the \fIraw\fR source, and package it up in a
the TAP::Parser::Iterator manpage for the parser to consume.
.PP
\&\f(CW\*(C`SourceHandlers\*(C'\fR must implement the \fIsource detection & handling\fR interface
used by the TAP::Parser::IteratorFactory manpage.  At 2 methods, the interface is pretty
simple: the can_handleand make_source entries elsewhere in this document.
.PP
Unless you're writing a new the TAP::Parser::SourceHandler manpage, a plugin, or
subclassing the TAP::Parser manpage, you probably won't need to use this module directly.
.SH "METHODS"
.IX Header "METHODS"
.Sh "Class Methods"
.IX Subsection "Class Methods"
.if n .I "\f(CW""can_handle""\fP"
.el .I "\f(CWcan_handle\fP"
.IX Subsection "can_handle"
.PP
\&\fIAbstract method\fR.
.PP
.Vb 1
\&  my $vote = $class->can_handle( $source );
.Ve
\&\f(CW\*(C`$source\*(C'\fR is a the TAP::Parser::Source manpage.
.PP
Returns a number between \f(CW\*(C`0\*(C'\fR & \f(CW\*(C`1\*(C'\fR reflecting how confidently the raw source
can be handled.  For example, \f(CW\*(C`0\*(C'\fR means the source cannot handle it, \f(CW\*(C`0.5\*(C'\fR
means it may be able to, and \f(CW\*(C`1\*(C'\fR means it definitely can.  See
the detect_source entry in the TAP::Parser::IteratorFactory manpage for details on how this is used.
.PP
.if n .I "\f(CW""make_iterator""\fP"
.el .I "\f(CWmake_iterator\fP"
.IX Subsection "make_iterator"
.PP
\&\fIAbstract method\fR.
.PP
.Vb 1
\&  my $iterator = $class->make_iterator( $source );
.Ve
\&\f(CW\*(C`$source\*(C'\fR is a the TAP::Parser::Source manpage.
.PP
Returns a new the TAP::Parser::Iterator manpage object for use by the the TAP::Parser manpage.
\&\f(CW\*(C`croak\*(C'\fRs on error.
.SH "SUBCLASSING"
.IX Header "SUBCLASSING"
Please see the SUBCLASSING entry in the TAP::Parser manpage for a subclassing overview, and any
of the subclasses that ship with this module as an example.  What follows is
a quick overview.
.PP
Start by familiarizing yourself with the TAP::Parser::Source manpage and
the TAP::Parser::IteratorFactory manpage.  the TAP::Parser::SourceHandler::RawTAP manpage is
the easiest sub-class to use as an example.
.PP
It's important to point out that if you want your subclass to be automatically
used by the TAP::Parser manpage you'll have to and make sure it gets loaded somehow.
If you're using the prove manpage you can write an the App::Prove manpage plugin.  If you're
using the TAP::Parser manpage or the TAP::Harness manpage directly (e.g. through a custom script,
the ExtUtils::MakeMaker manpage, or the Module::Build manpage) you can use the \f(CW\*(C`config\*(C'\fR option
which will cause the load_sources entry in the TAP::Parser::IteratorFactory manpage to load your
subclass).
.PP
Don't forget to register your class with
the register_handler entry in the TAP::Parser::IteratorFactory manpage.
.Sh "Example"
.IX Subsection "Example"
.Vb 1
\&  package MySourceHandler;
.Ve
.Vb 1
\&  use strict;
.Ve
.Vb 2
\&  use MySourceHandler; # see TAP::Parser::SourceHandler
\&  use TAP::Parser::IteratorFactory;
.Ve
.Vb 1
\&  use base 'TAP::Parser::SourceHandler';
.Ve
.Vb 1
\&  TAP::Parser::IteratorFactory->register_handler( __PACKAGE__ );
.Ve
.Vb 4
\&  sub can_handle {
\&      my ( $class, $src ) = @_;
\&      my $meta   = $src->meta;
\&      my $config = $src->config_for( $class );
.Ve
.Vb 19
\&      if ($config->{accept_all}) {
\&          return 1.0;
\&      } elsif (my $file = $meta->{file}) {
\&          return 0.0 unless $file->{exists};
\&          return 1.0 if $file->{lc_ext} eq '.tap';
\&          return 0.9 if $file->{shebang} && $file->{shebang} =~ /^#!.+tap/;
\&          return 0.5 if $file->{text};
\&          return 0.1 if $file->{binary};
\&      } elsif ($meta->{scalar}) {
\&          return 0.8 if $$raw_source_ref =~ /\ed\e.\e.\ed/;
\&          return 0.6 if $meta->{has_newlines};
\&      } elsif ($meta->{array}) {
\&          return 0.8 if $meta->{size} < 5;
\&          return 0.6 if $raw_source_ref->[0] =~ /foo/;
\&          return 0.5;
\&      } elsif ($meta->{hash}) {
\&          return 0.6 if $raw_source_ref->{foo};
\&          return 0.2;
\&      }
.Ve
.Vb 2
\&      return 0;
\&  }
.Ve
.Vb 8
\&  sub make_iterator {
\&      my ($class, $source) = @_;
\&      # this is where you manipulate the source and
\&      # capture the stream of TAP in an iterator
\&      # either pick a TAP::Parser::Iterator::* or write your own...
\&      my $iterator = TAP::Parser::Iterator::Array->new([ 'foo', 'bar' ]);
\&      return $iterator;
\&  }
.Ve
.Vb 1
\&  1;
.Ve
.SH "AUTHORS"
.IX Header "AUTHORS"
TAPx Developers.
.PP
Source detection stuff added by Steve Purkis
.SH "SEE ALSO"
.IX Header "SEE ALSO"
the TAP::Object manpage,
the TAP::Parser manpage,
the TAP::Parser::Source manpage,
the TAP::Parser::Iterator manpage,
the TAP::Parser::IteratorFactory manpage,
the TAP::Parser::SourceHandler::Executable manpage,
the TAP::Parser::SourceHandler::Perl manpage,
the TAP::Parser::SourceHandler::File manpage,
the TAP::Parser::SourceHandler::Handle manpage,
the TAP::Parser::SourceHandler::RawTAP manpage
