.\" Automatically generated by Pod::Man version 1.15
.\" Tue Sep 23 12:35:41 2014
.\"
.\" Standard preamble:
.\" ======================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R

.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used
.\" to do unbreakable dashes and therefore won't be available.  \*(C` and
.\" \*(C' expand to `' in nroff, nothing in troff, for use with C<>
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr
.\" for titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and
.\" index entries marked with X<> in POD.  Of course, you'll have to process
.\" the output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it
.\" makes way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.bd B 3
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ======================================================================
.\"
.IX Title "TAP::Parser::Aggregator 3"
.TH TAP::Parser::Aggregator 3 "perl v5.6.2" "2014-08-16" "User Contributed Perl Documentation"
.UC
.SH "NAME"
\&\s-1TAP:\s0:Parser::Aggregator \- Aggregate \s-1TAP:\s0:Parser results
.SH "VERSION"
.IX Header "VERSION"
Version 3.33
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use TAP::Parser::Aggregator;
.Ve
.Vb 3
\&    my $aggregate = TAP::Parser::Aggregator->new;
\&    $aggregate->add( 't/00-load.t', $load_parser );
\&    $aggregate->add( 't/10-lex.t',  $lex_parser  );
.Ve
.Vb 9
\&    my $summary = <<'END_SUMMARY';
\&    Passed:  %s
\&    Failed:  %s
\&    Unexpectedly succeeded: %s
\&    END_SUMMARY
\&    printf $summary,
\&           scalar $aggregate->passed,
\&           scalar $aggregate->failed,
\&           scalar $aggregate->todo_passed;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\f(CW\*(C`TAP::Parser::Aggregator\*(C'\fR collects parser objects and allows
reporting/querying their aggregate results.
.SH "METHODS"
.IX Header "METHODS"
.Sh "Class Methods"
.IX Subsection "Class Methods"
.if n .I "\f(CW""new""\fP"
.el .I "\f(CWnew\fP"
.IX Subsection "new"
.PP
.Vb 1
\& my $aggregate = TAP::Parser::Aggregator->new;
.Ve
Returns a new \f(CW\*(C`TAP::Parser::Aggregator\*(C'\fR object.
.Sh "Instance Methods"
.IX Subsection "Instance Methods"
.if n .I "\f(CW""add""\fP"
.el .I "\f(CWadd\fP"
.IX Subsection "add"
.PP
.Vb 1
\&  $aggregate->add( $description => $parser );
.Ve
The \f(CW\*(C`$description\*(C'\fR is usually a test file name (but only by
convention.)  It is used as a unique identifier (see e.g.
the section on "parsers".)  Reusing a description is a fatal error.
.PP
The \f(CW\*(C`$parser\*(C'\fR is a TAP::Parser object.
.PP
.if n .I "\f(CW""parsers""\fP"
.el .I "\f(CWparsers\fP"
.IX Subsection "parsers"
.PP
.Vb 3
\&  my $count   = $aggregate->parsers;
\&  my @parsers = $aggregate->parsers;
\&  my @parsers = $aggregate->parsers(@descriptions);
.Ve
In scalar context without arguments, this method returns the number of parsers
aggregated.  In list context without arguments, returns the parsers in the
order they were added.
.PP
If \f(CW\*(C`@descriptions\*(C'\fR is given, these correspond to the keys used in each
call to the \fIadd()\fR method.  Returns an array of the requested parsers (in
the requested order) in list context or an array reference in scalar
context.
.PP
Requesting an unknown identifier is a fatal error.
.PP
.if n .I "\f(CW""descriptions""\fP"
.el .I "\f(CWdescriptions\fP"
.IX Subsection "descriptions"
.PP
Get an array of descriptions in the order in which they were added to
the aggregator.
.PP
.if n .I "\f(CW""start""\fP"
.el .I "\f(CWstart\fP"
.IX Subsection "start"
.PP
Call \f(CW\*(C`start\*(C'\fR immediately before adding any results to the aggregator.
Among other times it records the start time for the test run.
.PP
.if n .I "\f(CW""stop""\fP"
.el .I "\f(CWstop\fP"
.IX Subsection "stop"
.PP
Call \f(CW\*(C`stop\*(C'\fR immediately after adding all test results to the aggregator.
.PP
.if n .I "\f(CW""elapsed""\fP"
.el .I "\f(CWelapsed\fP"
.IX Subsection "elapsed"
.PP
Elapsed returns a the Benchmark manpage object that represents the running time
of the aggregated tests. In order for \f(CW\*(C`elapsed\*(C'\fR to be valid you must
call \f(CW\*(C`start\*(C'\fR before running the tests and \f(CW\*(C`stop\*(C'\fR immediately
afterwards.
.PP
.if n .I "\f(CW""elapsed_timestr""\fP"
.el .I "\f(CWelapsed_timestr\fP"
.IX Subsection "elapsed_timestr"
.PP
Returns a formatted string representing the runtime returned by
\&\f(CW\*(C`elapsed()\*(C'\fR.  This lets the caller not worry about Benchmark.
.PP
.if n .I "\f(CW""all_passed""\fP"
.el .I "\f(CWall_passed\fP"
.IX Subsection "all_passed"
.PP
Return true if all the tests passed and no parse errors were detected.
.PP
.if n .I "\f(CW""get_status""\fP"
.el .I "\f(CWget_status\fP"
.IX Subsection "get_status"
.PP
Get a single word describing the status of the aggregated tests.
Depending on the outcome of the tests returns '\s-1PASS\s0', '\s-1FAIL\s0' or
\&'\s-1NOTESTS\s0'. This token is understood by the CPAN::Reporter manpage.
.Sh "Summary methods"
.IX Subsection "Summary methods"
Each of the following methods will return the total number of corresponding
tests if called in scalar context.  If called in list context, returns the
descriptions of the parsers which contain the corresponding tests (see \f(CW\*(C`add\*(C'\fR
for an explanation of description.
.Ip "\(bu failed" 4
.IX Item "failed"
.PD 0
.Ip "\(bu parse_errors" 4
.IX Item "parse_errors"
.Ip "\(bu passed" 4
.IX Item "passed"
.Ip "\(bu planned" 4
.IX Item "planned"
.Ip "\(bu skipped" 4
.IX Item "skipped"
.Ip "\(bu todo" 4
.IX Item "todo"
.Ip "\(bu todo_passed" 4
.IX Item "todo_passed"
.Ip "\(bu wait" 4
.IX Item "wait"
.Ip "\(bu exit" 4
.IX Item "exit"
.PD
.PP
For example, to find out how many tests unexpectedly succeeded (\s-1TODO\s0 tests
which passed when they shouldn't):
.PP
.Vb 2
\& my $count        = $aggregate->todo_passed;
\& my @descriptions = $aggregate->todo_passed;
.Ve
Note that \f(CW\*(C`wait\*(C'\fR and \f(CW\*(C`exit\*(C'\fR are the totals of the wait and exit
statuses of each of the tests. These values are totalled only to provide
a true value if any of them are non-zero.
.PP
.if n .I "\f(CW""total""\fP"
.el .I "\f(CWtotal\fP"
.IX Subsection "total"
.PP
.Vb 1
\&  my $tests_run = $aggregate->total;
.Ve
Returns the total number of tests run.
.PP
.if n .I "\f(CW""has_problems""\fP"
.el .I "\f(CWhas_problems\fP"
.IX Subsection "has_problems"
.PP
.Vb 3
\&  if ( $parser->has_problems ) {
\&      ...
\&  }
.Ve
Identical to \f(CW\*(C`has_errors\*(C'\fR, but also returns true if any \s-1TODO\s0 tests
unexpectedly succeeded.  This is more akin to \*(L"warnings\*(R".
.PP
.if n .I "\f(CW""has_errors""\fP"
.el .I "\f(CWhas_errors\fP"
.IX Subsection "has_errors"
.PP
.Vb 3
\&  if ( $parser->has_errors ) {
\&      ...
\&  }
.Ve
Returns true if \fIany\fR of the parsers failed.  This includes:
.Ip "\(bu Failed tests" 4
.IX Item "Failed tests"
.PD 0
.Ip "\(bu Parse errors" 4
.IX Item "Parse errors"
.Ip "\(bu Bad exit or wait status" 4
.IX Item "Bad exit or wait status"
.PD
.PP
.if n .I "\f(CW""todo_failed""\fP"
.el .I "\f(CWtodo_failed\fP"
.IX Subsection "todo_failed"
.PP
.Vb 1
\&  # deprecated in favor of 'todo_passed'.  This method was horribly misnamed.
.Ve
This was a badly misnamed method.  It indicates which \s-1TODO\s0 tests unexpectedly
succeeded.  Will now issue a warning and call \f(CW\*(C`todo_passed\*(C'\fR.
.SH "See Also"
.IX Header "See Also"
the TAP::Parser manpage
.PP
the TAP::Harness manpage
